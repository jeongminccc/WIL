# Docker

오픈소스 기반의 컨테이너 관리 플랫폼이다. 컨테이너에서 앱을 운영하고 관리하는데 필수적인 툴들을 제공한다.  

도커는 __image file을 계층화__ 하여 속도와 관리 측면에서 상당한 이점을 가진다. 이러한 장점으로 __롤백이 더 간단해졌으며__ 지속적인 통합 및 배포를 수행하는데 큰 도움을 주게 되었다. 도커 기술의 효용성은 세분화된 마이크로서비스 아키텍쳐와 잘 어울린다.  

```
Docker file : Docker image를 만들기 위한 스크립트가 담겨있다.

Docker image: 서비스 운영에 필요한 서버 프로그램이나 라이브러리, 소스코드, 바이너리 파일들을 패키징화 시킨 형태이다.

Docer Container : Docker image를 실행시킨 상태로, 어플리케이션 자체를 패키징, 캡슐화 하여 독립된 공간에서 프로세스를 동작시키는 기술이다.

롤백 : 업데이트에 오류가 발생했을 때 이전 단계로 되돌리는 것
```

MSA가 관심을 받으면서 자연스럽게 도커 기술 또한 흐름으로 받아지게 되었다. 하지만 도커는 많은 장점을 가진 기술이지만, __단일 컨테이너 관리에 적합하도록 설계되어 있다는 단점__ 이 있다. 세분화된 컨테이너와 컨테이너화된 앱이 늘어날 수록 관리 포인트가 늘어나 운영에 어려움을 겪게 된다.  

세분화된 컨테이너를 그룹화하여 네트워킹, 보안에 적합하도록 구성하면서 신속한 배포가 장점인 __도커 기술을 극대화할 수 있는 컨테이너 자동 확장 기능을 가진 오케스트레이션 툴__ 이 필요하게 되었고, 이것이 __Kubernetes__ 이다.  

- 도커 이외의 컨테이너 : Java 컨테이너, Unikernels, LXD, OpenVZ, Rkt 등

# Container Orchestration

컨테이너와 서비스들이 대규모로 운영 될 때, 컨테이너의 생명주기를 관리하는 것이다.  

수백대의 컨테이너와 서비스가 있는 경우 관리가 복잡해지고 어려워진다. 이렇게 대규모로 운영하는 경우 컨테이너 배치, 관리, 확장, 네트워킹과 컨테이너의 가용성을 자동화하는 컨테이너 오케스트레이션이 필수적이게 된다.  

컨테이너의 __생성과 소멸, 시작 및 중단 시점 제어, 스케줄링, 로드밸런싱, 클러스터링__ 등 컨테이너로 __어플리케이션을 구성하는 모든 과정을 관리__ 할 수 있음

- 컨테이너 __프로비져닝(자원상태를 파악, 필요시 실시간을 할당하는 서비스)과 배포__
- 컨테이너의 가용성과 Redundancy(필요 이상으로 존재하는 것) 관리
- 호스트 인프라에서 어플리케이션 로드 밸런싱을 위한 컨테이너 확장 및 제거
- 호스트가 죽거나 자원이 부족한 경우 다른 호스트로 컨테이너 이동
- 컨테이너 간 자원 할당
- 컨테이너를 외부와 연결할 수 있도록 해줌 (원래 컨테이너는 폐쇄적인 특성으로 외부와 단절)
- 컨테이너 간 로드밸런싱
- 컨테이너와 호스트의 상태 모니터링
- 어플리케이션을 운영중인 컨테이너와 관련한 어플리케이션 구성

Ex) Kubernetes, Docker swarm(소규모에 적합), Mesos, ECS, Nomad 등

## Container와 VM의 차이점

VM은 가상화된 HW위에 OS가 올라가는 형태로 99% host와 분리된다. __가상화된 HW위에 OS가 올라간다.__     

Container는 __OS를 가상화__ 시키기 때문에 OS 부분을 가상화해 올려 커널을 host와 공유한다.  

- Container는 커널을 공유하기 때문에, 들어온 I/O처리가 쉽고, VM은 guestOS, hostOS 따로 처리해주어야 하기때문에 성능이 좀 더 느리다.  

- VM은 HW가상화하고.. GuestOS 커널 시작하고...등등 오버헤드가 큰 반면, Docker는 프로세스를 위한 메모리만 필요하기때문에 오버헤드가 적다.  

- 하지만 Container는 host OS의 커널을 공유하므로 container하나가 뚫리면 바로 host 커널이 위험해지고, 모든 container에 영향을 미치게 된다. 즉, __보안에 취약__ 하다.

- 또한 Docker는 host OS와 다른 OS를 올릴수 없지만 VM은 전혀 다른 OS도 가상화시켜 올릴 수 있다.

<img src="https://miro.medium.com/max/770/1*wOBkzBpi1Hl9Nr__Jszplg.png"><br/>

### VM

Hypervisor가 HW 가상화를 하고, 그 위에 Guest OS가 올라간다. 

### Container (Docker)

Docker Engine 위에 어플리케이션에 실행에 필요한 Bins/Libs만 올라간다.  

- 도커가 다른 Container와 다른 가장 큰 장점은 라이프 사이클. Docker를 사용하면서 VM에 비해 가장 큰 장점은 __Microservices__ 로 발전할 수 있는 토대를 마련한다는 점이다. 

```
<도커의 라이프사이클>

버전업을 생각해보자. 어플리케이션의 소스를 고쳐 다시 배포를 하려면 VM에 접근해서 Repo를 Pull받고, 변경된 config를 변경하고... 일일히 다하려면 굉장히 복잡하다. Jenkins로 구성해도 스크립트의 에러문제 등..

하지만 Docker환경이라면 image를 만들고 레지스트리에 배포하고 새거 올리고 끝이다.
같은 Docker engine 위에서 이미 테스트했기 때문에 에러가 날 가능성이 매우 낮다. jenkins와 스크립트의 양에서도 차이가 날것이다. 

게다가 오케스트레이션까지 제공되어 여러대의 container를 관리해주며 병목현상이 생긴 container를 sclae out해주며 전체 서비스의 성능을 올릴수 있게되어 유연성도 생긴다. 
```

- Container는 __커널을 host와 공유__ 하기 때문에, 커널을 새로 시작할 필요도 없고 하드웨어 초기화 등의 작업도 필요없다. 단순히 프로세스를 새로 시작하는것과 같기 때문에 __빠르다__  
- 실행되는 프로세스를 위한 메모리만 필요하므로 __오버헤드가 적다__

## OCI와 CRI

## LXC와 Docker

초기 도커 기술은 LXC(Linux Container) 기술을 기반으로 구축되었으나 현재는 종속 관계를 벗어났다.  

<img src="http://accordions.co.kr/wp-content/uploads/2019/12/lxc_docker_1-768x437.png"><br/>

`LIB (정적으로 링크된 라이브러리)`  

LXC는 경량의 가상화 방법으로 탄생하였고, 큰 반응은 얻지 못하였다. 그에 비해 도커는 컨테이너를 생성 및 구축, 이미지 전송, 이미지 버전 관리 방법에 있어 많은 사용자 호응을 얻었다.  

도커 이미지 파일은 각각 계층으로 이루어져 단일 이미지로 결합된다. 만약 이미지가 변경되면 계층이 생성되고, 사용자가 실행, 복사 명령을 지정할 때 마다 새 계층이 생성된다. 새로운 도커 컨테이너를 구축할 때 이전 계층을 재사용하여 구축이 빠르게 진행된다. 중간 변경 사항이 있다면 변경 내용이 공유되며 개선된다. 버전 관리는 계층화와 관련이 있어 변경 사항이 새롭게 발생할 때마다 내장 변경 로그가 기본적으로 적용된다.  

### 출처
- https://blog.naver.com/PostView.nhn?blogId=mantechbiz&logNo=221380889496&parentCategoryNo=&categoryNo=1&viewDate=&isShowPopularPosts=true&from=search
- https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd

- 도커 vs 쿠버네티스 : https://wooono.tistory.com/109