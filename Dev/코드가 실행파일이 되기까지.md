# 기계어

컴퓨터가 사용하는 언어이다. 컴퓨터가 CPU의 명령을 처리할 때 사용하는 언어이며 2진법으로 구성되어 있다.  

기계어도 프로그래밍 언어이기 때문에 익숙해진다면 프로그래밍을 할 수는 있지만, 사람에게는 코드를 이해하거나 수정하는 작업은 어려울 수 밖에없다. 이를 조금더 알기쉽게 표현한 것이 16진법인데, 이렇게 변환해도 이해하기엔 여전히 어렵다.  

# 어셈블리어

기계어가 사용하는 숫자의 의미를 프로그래머가 외우는 것은 어렵다. 하지만 이 숫자의 의미를 사람이 좀 더 이해하기 쉬운 단어로만 변경해도 훨씬 더 편해질 것이다. 예를 들어, 기계어에서 전체적인 형식은 그대로 두고, 기계어의 특정 숫자(1000 1011)가 대입명령을 의미한다면, 이 숫자를 'mov'라는 단어로만 바꾸어 사용하는 것이 훨씬 더 편하다는 뜻이다.  

즉 __기계어에서 숫자를 의미있는 단어로 바꿔서 사람들이 이해하기 쉽게 만든 언어가 '어셈블리어'이다.__  

사실 이도 어셈블리어를 모르는 사람에게는 어렵겠지만, 그래도 기계어처럼 숫자로만 되어있는 것 보다는 어셈블리어로 적혀있는 명령어가 거부감이 적을 것이다.  

하지만 CPU는 어셈블리어를 이해할 수 없기 떄문에, 프로그래머가 어셈블리어로 작성한 프로그램 소스를 기계어로 번역해야지만 CPU가 사용할 수 있다. 이를 __"어셈블러(assembler)"__ 가 해준다.  

# 고급 언어 (High-Level Language)

프로그래밍 언어의 문법 구조가 기계어와 유사하면 Low-Level Language라고 부르고 사람들이 이해하기 편하도록 만들어진 프로그래밍 언어를 '고급 언어'라고 한다. 예를 들어 어셈블리어는 기계어와 문법구조가 유사하기 때문에 '저급 언어'라고 할 수 있고, C, C++, Java와 같은 언어는 '고급 언어'라고 할 수 있다.  

```
기계어 <-> 어셈블리어 <-> High-Level Language <-> 사람의 언어
```

고급언어를 사용하여 프로그래밍을 하면 CPU는 당연히 이해하지 못하고, 고급언어를 기계어로 변경해주는 프로그램인 __컴파일러__ 가 이를 해결해준다.  

# C언어와 컴파일러

앞서 기계어는 컴퓨터, 즉 CPU가 사용하는 언어라고 말했다. 여기서 문제점이 존재하는데, 세상에는 다양한 종류의 CPU가 존재하고, 각각의 CPU마다 명령체계, 즉 아키텍쳐가 다르기때문에 같은 기계어를 본다고 해도 CPU가 다르면 다르게 해석한다는 것이다.  

CPU마다 다른 명령체계를 가지고 있으니, 기계어와 일대일 대응이 되는 어셈블리어 또한 CPU마다 명령어 체계가 다르게 되고, 특정 CPU에서 동작하는 프로그램을 다른 CPU에도 동작하게 하려면 프로그램을 새로 짜야한다는 불편함이 존재하게 된다.  

이를 해결하기 위해 생겨난 것이 __C언어__ 이다. C언어는 메모리에 직접접근이 가능한 저급언어적 특징을 가지고있고, 절차지향적 특성을 가진 언어이다.  

그런데 이 C언어는 __컴파일러__ 라는 프로그램과 함께 등장 했는데, 이 컴파일러는 c언어, 파스칼등 고급언어로 구현된 프로그램 코드를 어셈블리 코드 혹은 기계어 등 다른 저급언어로 변환해 주는 프로그램을 말한다.  

따라서 컴파일 과정을 거치면 우리가 작성한 소스코드를 기계어나 어셈블리어로 변환해주고, 이 변환된 코드를 어셈블러 등이 기계어로 바꾼 뒤 비로소 컴퓨터가 이해할 수 있는 기계어인 __목적코드 (오브젝트 코드)__ 가 된다.  

목적 코드를 한데 엮어 __OS kernel__ 과 연결하여 __실행 파일(윈도우의 exe 파일)__ 로 만들어 주는역할은 __'링커'__ 가 한다. 여기까지의 과정을 거쳐 우리가 실행할 수 있는 프로그램이 완성되는 것이다.  

어셈블러와 마찬가지로, 컴파일러 또한 CPU마다 다른것이 당연할것이다. 그런데도 불구하고 Visual studio등의 프로그램이 CPU가 다른 컴퓨터들에서도 잘 작동하는 이유는, Windows OS에 한해 x86, x64, ARM등 각각의 CPU에 맞게 컴파일이 되도록 설계가 되었기 때문이다.  

## 운영체제와 링커

그러면 같은 프로그램을, 다른 OS (윈도우와 리눅스) 위에서 실행시키는 것은 가능할까? 아니다. 같은 CPU를 사용하더라도 불가능 한데, 이는 OS마다 kernel이 다르기 때문이다.  

C언어를 windows에서 컴파일 후 링크과정을 거치면 exe 파일이 나오는 반면, 리눅스에서는 .out 파일이 나온다. 즉 __OS마다 실행파일이 다르다는 것이다.__  

프로그래머가 만든 기계어인 목적코드를 각각의 OS의 실행파일로 만들기 위해선 각각의 OS의 포맷에 맞추어 구성해야 하는데, 이를 __링커__ 가 해준다. (링커는 어셈블러가 생성한 목적파일들을 결합하여 하나의 실행파일로 만드는 작업을 해준다)  

c언어를 컴파일 하면 .obj란 오브젝트 파일로 바뀌는데(리눅스는 .o 파일) 이 모든 오브젝트 파일들과 라이브러리 파일들을 한데 묶어 실행 파일인 .exe(리눅스는 .out)로 만들어 준다.  

- 실행파일이란 CPU에게 일을 시키기 위한 바이너리 형태의 명령어를 OS에서 요구하는 포맷에 맞춰 구성한 파일이다.  

```
즉, 소스파일 -> (전처리기) -> 컴파일러 -> 어셈블리어 -> 어셈블러 -> 오브젝트 파일(목적파일) -> 링커 -> 실행파일 이다.
```


### 출처
- https://psyhm.tistory.com/1