# TCP & UDP

TCP와 UDP는 Transport Layer의 프로토콜으로, 목적지까지 패킷의 이동과정을 담당한다.  

TCP는 패킷이 이동중에 순서가 바뀌거나 손실되는것을 방지해주고, UDP는 패킷을 빠르게 전달할 수 있도록 하여준다.  

## TCP

TCP의 가장 큰 특징은 패킷의 이동과정중 __오류 제어, 흐름 제어, 혼잡 제어__ 를 이루어 준다는 것이다. (+ 순서 정립)  

- 오류 제어 : __패킷이 전달과정중에 손실되는 것을 해결해 준다.__ SYN flag와 ACK flag를 사용하여 패킷이 잘 전달 되었는지 확인할 수 있다. 

오류 제어 방식

- (1) __Stop and Wait__ : 매번 패킷을 보낸 후 ACK 패킷을 받고나면 다음 패킷을 보내는 방식
- (2) __Go Back N__ : 연속된 패킷을 보낸 후 누락된 패킷부터 다시 보내는 방식
- (3) __Selective Repeat__ : 연속된 패킷을 보낸 후 누락 된 패킷만 보내는 방식 (이 방식에선 버퍼를 또 할당해야 한다는 오버헤드가 있음)  

- 흐름 제어 : __수신자가 받을 수 있는 용량 이상을 송신자가 보냈을때, 패킷의 손실이 일어나는 것을 제어해준다.__   

흐름 제어의 방식  

- (1) __Stop and Wait__ : 매번 패킷을 보내고 ACK 패킷을 받은 뒤에야 다음 패킷을 보내는 방식
- (2) __Sliding Window__ : 수신자가 가용할 수 있는 크기만큼 윈도우를 만들어 윈도우만큼씩만 패킷을 보내는 방식   

- 혼잡 제어 : __패킷의 이동 중 특정 라우터에 과도하게 몰려 패킷이 손실되는 것을 제어해준다.__  

혼잡 제어의 방식  

- (1) __AIMD(Additive Increase / Multiplicative Decrease)__ : 패킷을 하나씩 보내고 문제가 없으면 Window의 크기를 '1'씩 증가하며 전송, 전송에 실패할 시 window를 '절반'으로 줄이는 방법이다. -> __초기에 네트워크의 높은 대역폭을 사용하지 못하고 오랜시간이 걸린다는 단점__  
- (2) __Slow Start__ : 패킷을 하나 보내고 문제가 없으면 window의 크기를 '2배(지수 함수꼴)'씩 증가하며 전송, 전송에 실패할 시 window를 '1'로 떨어뜨리고, 이후부터는 '1'씩 증가시킨다. -> __한번 혼잡 현상이 발생하면 네트워크의 수용량을 어느정도 예상할 수 있다는 장점__  
- (3) __Fast Recovery__ : 혼잡한 상태가 되면 window size를 1로 줄이는 것이 아닌 '절반'으로 줄인 뒤, 선형 증가시키는 방법이다. 이후부터는 순수한 AIMD 방식으로 동작한다.  
- (4) __Fast Retransmit__ : 패킷의 전송을 확인하는 ACK 패킷을 받는 도중, 중복된 ACK 패킷을 
'3'개 받는 경우 혼잡한 상황이라고 판단, window size를 줄인다. 

<center><<img src="https://t1.daumcdn.net/cfile/tistory/256E39425715F10103"><br/>/center>