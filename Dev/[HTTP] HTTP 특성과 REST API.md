# HTTP

HTTP의 가장 큰 특징인 __비연결성__, __무상태__ 와 HTTP __상태코드__ 와 __메서드__, __헤더__ 에 대해 알아보자.

## 비연결성 (Connectionless)

HTTP 프로토콜은 연결을 한번 맺은후 __끊어버린다__. 왜냐하면 HTTP는 인터넷 상에서 불특정 다수의 통신 환경을 기반으로 설계되어 있기때문에, 서버에서 다수의 클라이언트와 연결해야 한다면 __많은 리소스기 발생하게 된다.__ 따라서 연결을 유지하기 위한 리소스를 줄임으로써, __더 많은 연결을 할 수 있도록__ 한다.  

- 단점 : 서버는 클라이언트를 기억하고 있지 않아서, 동일한 클라이언트의 모든 요청에 대해 매번 새로운 연결을 시도/해제의 과정을 거쳐야 하므로 __오버헤드가 발생__ 한다.  

- KeepAlive : 오버헤드를 줄이기 위해 HTTP의 KeepAlive 속성을 사용할 수 있다. KeepAlive란 지정된 시간동안 서버와 클라이언트 사이에서 패킷 교환이 없을경우, __상대방의 상태를 확인하기위해 패킷을 주기적으로 보내는 것__ 이다. 이에대한 반응이 없을경우 연결을 끊게 된다. (하지만 주기적으로 체크하는데에 발생하는 오버헤드도 상당하기에, 완벽한 해결책은 아니다)  

## 무상태 (Stateless)

Connectionless로 인해 __서버가 클라이언트를 식별할 수가 없을때__, 이를 Stateless라고 한다. 클라이언트의 상태를 모른다는 것은, 클라이언트가 로그인을 했음에도 불구하고 계속해서 로그인을 요구하는 것이다. 즉, 매번 새로운 인증을 요구하게 된다.  

이러한 무상태를 해결하기 위해 세가지의 방법이 있다. __쿠키, 세션, 토큰(OAuth, JWT)__  

### 쿠키

__set-cookie__ 라는 HTTP 헤더를 사용한다. 브라우저 단에서 쿠키라는 것을 저장하여 서버가 클라이언트를 식별할 수 있도록 한다.  

__But,__ 쿠키는 사용자의 정보가 브라우저에 저장되기 때문에 공격자로부터 위변조의 가능성이 높아 보안에 취약하다.  

### 세션

세션은 브라우저가 아닌 __서버단에서 사용자 정보를 저장하는 구조__ 이다. 따라서 쿠키보다는 안전하다고 할 수 있다.  

__But,__ 세션 정보도 중간에 탈취당할 수 있기때문에, 보안에 완벽하다고는 할 수 없다. 또한 세션을 사용하면 서버에 사용자 정보를 저장하기 때문에 __서버 과부하의 원인__ 이 된다.  

### 토큰 (OAuth, JWT)

쿠키와 세션의 문제점들을 보완하기 위해 토큰기반의 인증 방식이 도입되었다.  

토큰 기반 인증 방식의 핵심은 __보호할 데이터를 토큰으로 치환하여 원본 데이터 대신 토큰을 사용하는 기술__ 이다.  

그래서 중간에 공격자로부터 토큰이 탙취당하더라도 데이터에 대한 정보를 알 수 없으므로, 보안성이 높은 기술이라고 할 수 있다.  

__But,__ 꼭 토큰 기반의 인증이 가장 좋다고는 할 수없다. 서비스에 따라 기술의 특징을 잘 이해하여 때에 따라 __쿠키, 세션, 토큰 기법들을 적절히 사용하는것이 좋다.__  

## 응답 상태코드

클라이언트가 서버에 요청을 하면, 서버는 __요청에 대한 처리 상태__ 를 숫자로 반환하는데 이를 __응답코드__ 라 한다.  

HTTP 응답에는 __상태 코드를 헤더에 추가__ 하여 응답을 한다. 

```
- 100 - 109 : 메세지 정보
- 200 - 206 : 요청 성공
- 300 - 305 : 리다이렉션
- 400 - 415 : 클라이언트 에러
- 500 - 505 : 서버에러
```

__API 개발 시 올바른 상태코드를 응답하는 것은 매우 중요하다.__

## HTTP Method 

클라이언트가 서버로 요청을 할 떄, __어떠한 목적을 갖는 행위인지 HTTP 메서드에 명시__ 한다.  

- __GET__ : 요청받은 URI의 정보를 검색하여 응답한다.  __(조회)__
- __HEAD__ : GET과 동일하지만, 응답에 BODY가 없고 응답 코드와 HEAD만 응답한다. 웹서버 정보확인, 상태 체크, 버전 확인등의 용도로 사용된다.  
- __DELETE__ : 서버에서 요청 URI 리소스를 삭제하도록 요청 __(삭제)__
- __POST__ : 요청된 자원을 __생성(CREATE)__ 한다. 
- __PUT__ : 요청된 자원을 __수정(UPDATE)__ 한다.  
- __PATCH__ : PUT과 유사하게 요청된 자원을 수정하는데, PUT은 자원의 전체를 갱신하지만 PATCH는 해당 자원의 일부를 수정한다.  

``` 
POST와 PUT을 구분하는데 '멱등성'이 가장 중요하다.

동일한 자원을 여러번 POST하면 서버자원에는 변화가 생기므로 멱등하지 않지만,
여러번 PUT하는 경우는 변화가 생기지 않으므로 멱등하다고 말할 수 있다.
```

- __TRACE__ : 원격지 서버에 루프백 메세지 호출하기 위한 테스트용
- __OPTIONS__ : 웹 서버에서 지원되는 메소드의 종류를 확인하기 위함

# REST와 Restful API, HTTP Method

REST란, 웹 초기에 "웹을 무너뜨리지 않고 어떻게 HTTP 프로토콜을 발전 시킬 수 있을까?"에 대한 고민으로 시작된 __아키텍쳐__ 이다.  

REST API란 이러한 REST 아키텍쳐를 따르는 API이다.  
대부분의 API는 HTTP만 잘 따라도 어느정도 REST를 만족하는데, 이를 __Restful__ 이라고 한다.  

- URI에 어떤 __자원에 대한 경로__ 인지를 명사로 작성
- HTTP Method에 어떤 __행위__ 를 하고자 하는 것인지를 작성

```
하지만 두가지의 제약조건으로 인해, 대부분의 REST API라고 알려진 것들이 REST API가 아니라고 한다.

- 'self-descriptive messages' : 메세지 자체만으로 스스로를 설명할 수 있어야한다.
- 'HATEOAS' : 어플리케이션의 상태는 하이퍼링크를 통해 전이되어야한다.

따라서 완벽한 REST API를 구현하는것은 어렵다고 한다.
```

## Restful API

그렇다면 완벽한 REST API를 만들기는 어렵고, Restful하게는 어떻게 만들까?

- Restful 하지 않은 URI (요청 행위를 URI에 명시하고 있기때문)

```
- 게시글 조회 : http://example.com/showPost
- 게시글 추가 : http://example.com/addPost
```

- HTTP Method를 이용한 Restful API

```
- 게시글 조회
    - URI : http://example.com/post
    - HTTP Method : GET
- 게시글 추가
    - URI : http://example.com/post
    - HTTP Method : POST
```

이렇게 Restful API로 설계하면, URI 매핑이 깔끔해지고 의미도 명확해진다.

# HTTP Header

HTTP 프로토콜 상에서 클라이언트와 서버는 데이터를 패킷 단위로 잘게 쪼개어 통신을 한다.  

데이터 전송 단위인 패킷에는 요청/응답에 대한 메세지가 담겨있는데, 패킷의 구조는 다음과 같다.  

- 시작라인 (Request Line)
- 헤더 (Header)
- 본문 (Body)

<img src ="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F9943544C5BB4BF5231E17E"><br/>

그중에서 헤더에는 패킷에 대한 정보들을 담고있다. 헤더에 대한 정보들에는 "Date, Via, client-IP... 등등" 굉장히 많다.  

### 출처
- https://victorydntmd.tistory.com/286?category=719464